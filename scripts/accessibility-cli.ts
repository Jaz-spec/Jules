#!/usr/bin/env node

import { execSync } from 'child_process';
import { readFileSync, existsSync, realpathSync } from 'fs';
import { fileURLToPath } from 'url';

class AccessibilityCLI {
  private currentBranch: string = '';
  private newBranch: string = '';

  constructor() {
    this.getCurrentBranch();
    this.generateBranchName();
  }

  private getCurrentBranch(): void {
    try {
      this.currentBranch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
      console.log(`üìç Current branch: ${this.currentBranch}`);
    } catch (error) {
      console.error('‚ùå Failed to get current branch. Are you in a git repository?');
      process.exit(1);
    }
  }

  private generateBranchName(): void {
    const timestamp = Date.now();
    this.newBranch = `accessibility-improvements-${timestamp}`;
  }

  private checkGeminiAuth(): void {
    try {
      execSync('gemini --version', { stdio: 'pipe' });
      console.log('‚úÖ Gemini CLI available');
    } catch (error) {
      console.error('‚ùå Gemini CLI not found. Install with: npm install -g @google/gemini-cli');
      process.exit(1);
    }
  }

  private loadGuidelines(): string {
    try {
      const content = readFileSync('access-info.md', 'utf-8');
      return content;
    } catch (error) {
      console.error('‚ùå Could not load access-info.md');
      process.exit(1);
    }
  }

  private createBranch(): void {
    try {
      console.log(`üåø Creating new branch: ${this.newBranch}`);
      execSync(`git checkout -b ${this.newBranch}`, { stdio: 'inherit' });
    } catch (error) {
      console.error('‚ùå Failed to create new branch');
      process.exit(1);
    }
  }

  private findRelevantFiles(): string[] {
    try {
      const gitFiles = execSync('git ls-files', { encoding: 'utf-8' })
        .split('\n')
        .filter(file => file.trim() && this.isRelevantFile(file));
      
      return gitFiles;
    } catch (error) {
      console.error('‚ùå Failed to get git files');
      return [];
    }
  }

  private isRelevantFile(fileName: string): boolean {
    const extensions = ['.html', '.tsx', '.jsx', '.vue', '.svelte'];
    return extensions.some(ext => fileName.endsWith(ext));
  }

  private async runAccessibilityCheck(file: string, guidelines: string): Promise<void> {
    if (!existsSync(file)) return;
    
    const prompt = `Based on the following accessibility guidelines, please review and fix any issues in the provided file. Apply the changes directly.\n\nGuidelines:\n${guidelines}`;
    
    try {
      console.log(`  Processing ${file}...`);
      execSync(`gemini code --file "${file}" --apply`, {
        input: prompt,
        stdio: 'pipe',
        timeout: 60000
      });
      console.log(`  ‚úÖ ${file}`);
    } catch (error) {
      console.log(`  ‚ö†Ô∏è  Skipped ${file}. Reason:`);
      console.error(error.stderr.toString());
    }
  }

  private commitChanges(): boolean {
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf-8' });
      if (!status.trim()) {
        console.log('‚ÑπÔ∏è  No changes to commit');
        return false;
      }

      console.log('üìù Committing changes...');
      execSync('git add .', { stdio: 'inherit' });
      execSync('git commit -m "feat: automated accessibility improvements via Gemini CLI"', { stdio: 'inherit' });
      return true;
    } catch (error) {
      console.error('‚ùå Failed to commit changes');
      return false;
    }
  }

  private pushBranch(): void {
    try {
      console.log('üöÄ Pushing branch to remote...');
      execSync(`git push -u origin ${this.newBranch}`, { stdio: 'inherit' });
    } catch (error) {
      console.error('‚ùå Failed to push branch');
      process.exit(1);
    }
  }

  private createPR(): void {
    try {
      console.log('üìã Creating pull request...');
      const prBody = `
# Automated Accessibility Improvements

This PR contains accessibility improvements generated by the Gemini CLI based on guidelines in \`access-info.md\`.

## Changes Made
- Accessibility fixes applied to all relevant HTML, JSX, Vue, and Svelte files.
- Generated via an automated script.

## Files Modified
Run \`git diff ${this.currentBranch}..${this.newBranch} --name-only\` to see all changed files.

Ready for review! üöÄ
      `.trim();

      execSync(`gh pr create --title "Automated Accessibility Improvements (Gemini CLI)" --body "${prBody}" --base ${this.currentBranch}`, { 
        stdio: 'inherit' 
      });
      
      console.log('‚úÖ Pull request created successfully!');
    } catch (error) {
      console.error('‚ùå Failed to create PR. Make sure GitHub CLI is installed and authenticated.');
    }
  }

  private switchBackToBranch(): void {
    try {
      console.log(`üîÑ Switching back to ${this.currentBranch}`);
      execSync(`git checkout ${this.currentBranch}`, { stdio: 'inherit' });
    } catch (error) {
      console.log('‚ö†Ô∏è  Could not switch back to original branch');
    }
  }

  public async run(): Promise<void> {
    console.log('üéØ Starting Gemini CLI Accessibility Tool...\n');
    
    this.checkGeminiAuth();
    
    const guidelines = this.loadGuidelines();
    console.log('üìã Loaded accessibility guidelines from access-info.md\n');

    const relevantFiles = this.findRelevantFiles();
    if (relevantFiles.length === 0) {
      console.log('ü§∑ No relevant files found to check.');
      return;
    }
    console.log(`üîé Found ${relevantFiles.length} relevant files to check.`);

    this.createBranch();

    try {
      console.log(`üîß Running accessibility checks...`);
      for (const file of relevantFiles) {
        await this.runAccessibilityCheck(file, guidelines);
      }

      const hasChanges = this.commitChanges();
      
      if (hasChanges) {
        this.pushBranch();
        this.createPR();
        console.log('\nüéâ Accessibility improvements completed!');
        console.log(`üìä Check your PR and merge when ready.`);
      } else {
        console.log('\nüí° No accessibility improvements needed at this time.');
      }

    } finally {
      this.switchBackToBranch();
    }
  }
}

if (process.argv[1] && realpathSync(process.argv[1]) === fileURLToPath(import.meta.url)){
  const cli = new AccessibilityCLI();
  cli.run().catch(error => {
    console.error('üí• CLI failed:', error.message);
    process.exit(1);
  });
}

export default AccessibilityCLI;
